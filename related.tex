

%common lsm stores RocksDB, scylladb, HyperLevelDB, LevelDB, hbase, cassandra
The vast majority of industrial mainstream key-value stores are  implemented as LSM data
stores~\cite{Bigtable2008,hbase,cassandra2010,RocksDB, scylladb}, building on the foundation set by the original LSM-tree key-value store~\cite{O'Neil1996, Muth1998}.

Due to their popularity, much work has been dedicated in recent years for optimizing their implementation. Some work aims to increase performance of workloads that can be served from 
RAM by optimizing the LSM memory component~\cite{clsm2015, accordion}. Other focus on reducing write amplification and increasing throughput either by applying storage optimizations~\cite{WiscKey, PebblesDB}, or by levereging the skewness of many workloads to tackle the problem earlier at the memory level~\cite{ accordion, triad}.
Specifically, PebblesDB~\cite{PebblesDB} introduces fragmented LSM tree structure which stores the leveled files in a skip-list like layout by dividing each level into guards of increasing granulrity. In contrast, \sys\ eliminates all leveling of the storage files. 
%Accordion~\cite{accordion} is a new write-path algorithm for LSM stores. 
Accordion~\cite{accordion} maintains a small dynamic memory component to absorb write operation. This active component is frequently merged with a larger immutable in-memory component by running in-memory flush and compaction at the background. This mechanism is somewhat similar to the rebalance mechanism used in \sys, however, \sys\ applies rebalance per chunk, while Accordion runs in-memory compaction for the entire store.



Wisckey - optimizatoin towards ssd storage

$\epsilon^+$-trees and implelentations like Tucana~\cite{tucana}.

in-memory kv stores memcached ignite redis